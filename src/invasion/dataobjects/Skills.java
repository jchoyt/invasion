/*
 *  Copyright 2010 Jeffrey Hoyt.  All rights reserved.
 */
package invasion.dataobjects;

import java.util.logging.Level;
import java.util.logging.Logger;
import invasion.util.*;

import java.util.*;
import java.sql.*;

/**
 * Skills generated by hbm2java
 */
public class Skills implements java.io.Serializable
{

    public final static String KEY = Skills.class.getName();
    public final static Logger log = Logger.getLogger( KEY );
    // static{log.setLevel(Level.FINER);}

    //{{{ Members
     private static Map<String, Skill> byName = new HashMap<String, Skill>();
     private static Map<Integer, Skill> byId = new HashMap<Integer, Skill>();
	 protected static List<Skill> humanSkills = new ArrayList<Skill>();
	 protected static List<Skill> psiSkills = new ArrayList<Skill>();
	 protected static List<Skill> mutateSkills = new ArrayList<Skill>();

    //}}}

    //{{{ Constuctors
    //}}}

    //{{{ Methods
     public static void load()
     {
        String query = "select s.*, t.id as prereqid, t.name prereqname from skills s left outer join skills t on s.prerequisite = t.id order by s.id";
        //NOTE the query above relies on the skills in the database being inserted such that prerequisite skills are inserted *before* the skills that rely on them
        InvasionConnection conn = null;
        ResultSet rs = null;
        try
        {
            conn = new InvasionConnection();
            rs = conn.executeQuery(query);
            while(rs.next())
            {
                Skill s = new Skill();
                s.setId(rs.getInt("id"));
                s.setValue(rs.getLong("value"));
                s.setRace(rs.getString("race"));
                s.setName(rs.getString("name"));
                s.setPrereq(rs.getInt("prereqid"));
                s.setCost(rs.getInt("cost"));
                s.setHelplink( rs.getString("helplink") );
                addSkill(s);
                log.finer("Loaded " + s.getName() );
            }
        }
        catch(SQLException e)
        {
            log.throwing( KEY, "Massive problem - error loading Skills list", e);
            throw new RuntimeException(e);
        }
        finally
        {
            DatabaseUtility.close(rs);
            conn.close();
        }
     }

     /**
      * Adds the skill to the various ways of accesing them.  By Id and name.  Also the full heirarchical structure and grouped by race type.
      * @param       s The skill to be added
      *
      */
     public static void addSkill( Skill s )
     {
         byName.put( s.getName(), s );
         byId.put( s.getId(), s );
         /* If this is a base skill (e.g., firearms 1) add it to the race type.  Otherwise just make it a child of it's parent. */
         if( s.getRace().equals( Skill.HUMAN ) )
         {
             if( s.getPrereq() == 0 )
                 humanSkills.add(s);
         }
         else if( s.getRace().equals( Skill.PSI ) )
         {
             if( s.getPrereq() == 0 )
                 psiSkills.add(s);
         }
         else if( s.getRace().equals( Skill.MUTATE ) )
         {
             if( s.getPrereq() == 0 )
                 mutateSkills.add(s);
         }
         else
             throw new RuntimeException("Database fucked up. Race needs to be human, psi, or mutate.  Was " + s.getRace() );
         if( s.getPrereq() > 0 )
         {
             Skill parent = byId.get( s.getPrereq() );
             parent.addChild( s );
             log.finer( s.getName() + " should be added as a child of " + parent.getName() );
         }

     }

     /**
      * Checks the skill type checks against the appropriate skills field.
      * @param  who The character to check against
      * @param  what The skill to see if the character has
      * @return  true if the character has the skill
      *
      */
     public static boolean hasSkill( Alt who, Skill what )
     {
         if( what.getRace().equals( Skill.HUMAN ) )
         {
             return (who.getHumanSkills() & what.getValue()) > 0;
         }
         else if( what.getRace().equals( Skill.PSI ) )
         {
             return (who.getPsiSkills() & what.getValue()) > 0;
         }
         else if( what.getRace().equals( Skill.MUTATE ) )
         {
             return (who.getMutateSkills() & what.getValue()) > 0;
         }
         else
             throw new RuntimeException( "Skill incorrectly set" );
     }

     public static Long getValue( String skill )
     {
         return byName.get(skill).getValue();
     }

     public static Skill getById( int id )
     {
         return byId.get(id);
     }

     /**
      * Calculates the chances of an attack landing
      * @param       attackerLevel Example: 5 if attacker has Firearms 5
      * @param       dodgeLevel Example: 3 if attacker has Dodge 3 or Melee 5
      * @param       baserate base chance of attacking with that weapon (imporvised or not)
       *
      */
     public static double calculateAttackChance ( double baserate, int attackerLevel, int dodgeLevel)
     {
         return ( 1.0d + baserate - Math.pow( baserate, attackerLevel / 6.0d ) ) * ( 1 - Math.cos( ( Math.PI / 2 ) - ( dodgeLevel * Math.PI / 15 ) ) );
     }
    //}}}

    //{{{ Getters and Setters
    public static List<Skill> getHumanSkills() { return humanSkills; }
	// public void setHumanSkills(List<Skill> humanSkills) { this.humanSkills = humanSkills; }
	public static List<Skill> getMutateSkills() { return mutateSkills; }
	// public void setMutateSkills(List<Skill> mutateSkills) { this.mutateSkills = mutateSkills; }
	public static List<Skill> getPsiSkills() { return psiSkills; }
	// public void setPsiSkills(List<Skill> psiSkills) { this.psiSkills = psiSkills; }
    //}}}
}

// :wrap=none:noTabs=true:collapseFolds=1:folding=explicit:


